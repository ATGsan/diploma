\section{Оптимизация бинарного поиска}\label{binary_search}
\par{Бинарный поиск является одним из самых известных и ключевых алгоритмов. Он применяется во множестве задач где мы имеем дело с отсортированными данными, так как он на порядки быстрее чем его аналог линейный поиск.}
\par{Он имеет две версии в стандартной библиотеке -- std::lower\_bound(левый бинарный поиск\footnote{в подпоследовательности одинаковых элементов будет найден первый}), std::upper\_bound(правый бинарный поиск\footnote{в подпоследовательности одинаковых элементов будет найден последний}). Стандарт накладывает сравнительно небольшие ограничения на эти две функции:
\begin{enumerate}
    \item{Сложность алгоритма по времени -- $O(\log n)$, где $n$ -- размер интервала поиска;}
    \item{Сложность по памяти -- $O(1)$;}\label{binary_search::bounds::space_complexity}
    \item{Исходный интервал не должен быть изменен.}\label{binary_search::bounds::immutability}
\end{enumerate}
Под эти требования подходит общеизвестный алгоритм биннарного поиска<ссылка на Кнута или Кормена>. Однако на практике выясняется, что этот алгоритм может работать значительно быстрее, при этом не нарушая существующих требований. 
}
\subsection{Описание оптимизации}
\par{Существует множество вариантов оптимизации бинарного поиска, например:<вставить примеры из modern hardware>
\begin{enumerate}
    \item{}
    \item{}
    \item{}
\end{enumerate}
Однако все они не подходят так как нарушают или требование \ref{binary_search::bounds::space_complexity}, или требование \ref{binary_search::bounds::immutability}. 
}
\par{Но в данной книге еще упоминается оптимизация, значительно ускоряющая реальную скорость выполнения, при этом не влияющая на ассимптотики и не изменяющая сам массив. Эта оптимизация использует линейный поиск на последних этапах бинарного. В виду особенностей кэша процессора и конвейеризация вычисления это будет значительно быстрее. Описание подробностей того, за счет чего происходит выигрыш.}
\subsection{Обоснование работы}
\par{Современные процессоры редко выполняют операции с одним атомом памяти. Чаще всего они стараются вместе с выполнением взять какую-то полезную нагрузку. Например при чтении данных из памяти мы будем читать не один элемент, а всю его кэш линию\footnote{Кэш-линия - это небольшой блок памяти, используемый для хранения часто используемых данных из более медленной памяти, такой как оперативная память. Кэш-линия обычно имеет фиксированный размер и хранит не больше нескольких десятков байт}. Что касается выполнения инструкций, то при последовательном выполнении одинаковых инструкций процессор может заранее выполнить какие-то инструкции(например с помощью векторизации вычислений\footnote{Векторизация вычислений - это метод оптимизации заключающийся в замене последовательности операций с отдельными элементами данных на операции над векторами данных, то есть наборами элементов, обрабатываемыми одновременно.}). Таким образом мы сможем ускорить проверку внутри цикла когда заранее известно какой элемент будет рассмотрен следующим(то есть нет выбора). Однако наше улучшение не воздействует на бинарный поиск на любых данных -- ввиду того, что функция сравнения двух элементов может изменять внешнее состояние, введя линеаризацию мы можем изменить ожидаемое поведение. Для того, что бы обойти это ограничение мы специализировали нашу функцию на бинарном поиске среди элементов арифметического типа и использующих стандартный компаратор. Благодаря тому, что C++ не позволяет переопределить операторы сравнения для стандартный типов мы можем быть уверены, что наше изменение не повлияет на внешние данные. 
}
\begin{figure}[t]
\begin{lstlisting}[caption={Предложенное изменения бинарного поиска}, label={listing::binary_search}]
  template<typename Iter, typename T, typename Compare>
  typename std::enable_if<std::is_arithmetic<T>::value && (
           std::is_same<Compare, std::greater<T>>::value ||
           std::is_same<Compare, std::less<T>>::value), Iter>::type 
  lower_bound(Iter begin, Iter end, const T& val, Compare comp) {
    constexpr size_t binsearch_distance = std::hardware_constructive_interference_size / sizeof(T); 
    typedef typename std::iterator_traits<Iter>::difference_type _DistanceType;
    _DistanceType len = std::distance(begin, end);
    while (len > binsearch_distance) {
      _DistanceType half = len >> 1;
      Iter middle = begin;
      std::advance(middle, half);
      if (comp(*middle, val)) {
        begin = middle;
        ++begin;
        len = len - half - 1;
      } else {
        len = half;
      }
    }
    for (auto i = begin ; i != end ; ++i) {
        if (!comp(*i, val)) {
            return i;
        }
    }
    return end;
  }
\end{lstlisting}
\end{figure}
\newpage
Разберем строки на листинге \ref{listing::binary_search}, которые отличаются от оригинального алгоритма
\begin{enumerate}
    \item{Строки 2-4 -- для того, что бы мы смогли специализировать нашу функция нам потребовалось использовать SFINAE\footnote{SFINAE -- substitution failure is not an error, парадигма которая позволяет "отключать" функции при не выполнении каких-то условий на этапе компиляции.} со сложным условием внутри;}
    \item{Строка 6 -- вычисление длины отрезка, начиная с которой исполнение переключится на линейный поиск. \\
    Константа std::hardware\_constructive\_interference\_size -- длина кэш-линии в байтах. Поделив длину кэш-линии на размер искомого типа узнаем когда сменить тип поиска(как только длина отрезка станет меньше или равной результату вычисления);}
    \item{Строка 9 -- отличие от оригинала заключается в том, что сравниваем не с 0, а с binsearch\_distance;}
    \item{Строки 21-25 -- цикл линейного поиска, который может быть соптимизирован до векторных операций(зависит от выравнивания данных), но если этого не произойдет то всегда будет использован механизм конвейеризации.}
\end{enumerate}
\subsection{Тесты}
Это улучшение позволяет выиграть в бинарном поиске на десятки процентов. Мы проводили исследования меняя несколько параметров: размер интервала поиска, тип переменной, параметр линеаризации. Приведем ниже графики<приведи ниже графики>
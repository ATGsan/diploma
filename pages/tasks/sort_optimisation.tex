\section{Оптимизация сортировки}\label{sort}
\par{Сортировка является одним из главных алгоритмов в любой области программирования. И даже сравнительно небольшое ускорение приведет к существенной оптимищзации утилизации ресурсов. Мы же смогли ускорить алгоритм сортировки в библиотеке GCC для определенных типов данных на порядок -- было $O(n\log n)$ стало $O(n)$. }
\subsection{Описание оптимизации}
\par{У сортировки в стандарте есть несколько ограничений
\begin{enumerate}
    \item{Сортировка должна быть стабильной\footnote{Сортировка является стабильной когда равные элементы в изначальном массиве сохраняют порядок в отсортированном.}}
    \item{Сложность по времени -- $O(n\log n)$}
    \item{Сложность по памяти -- $O(1)$}\label{sort::req::memory}
\end{enumerate}
Исходя из этих требований, например, невозможно добавить сортировку сравнениями(это нарушит требование \ref{sort::req::memory}). Однако мы нашли способ как ускорить сортировку.}
\par{Если посмотреть на то как сортируются типы данных с крайне ограниченым диапозоном значений(например bool), то мы увидим большое количество ненужных действий, что повлияет на итоговую сложность по времени. Однако если мы специализируем нашу сортировку для такого типа данных, и запустим вместо него функцию std::partition\footnote{std::partition -- функция разделения массива данных на две части по результату унарного предиката. Сложность по времени $O(n)$} то сможем существенно выиграть.}
\par{Встает резонный вопрос -- кому может понадобиться отсортировать массив булевых значений? Действительно это используется крайне редко, однако сортировка какого-то массива структур по одному из полей с типом bool явление куда более частое<Можно ли найти пример в опенсорс или сослаться на голые данные яндекса>. Таким образом перед нами появляется последняя проблема -- понять что мы сортируем булевые значения. Во время нашего исследования мы не смогли решить это средствами C++17 и старше. Однако в новой библиотеке алгоритмов std::ranges у сортировки появилась возможность выбрать проекцию -- поле внутри структуры по которому будет выполняться сортировка. Специализирую этот тип мы получим возможность существенно ускорить алгоритм. С помощью спецификатора requires добавленному в C++20 мы можем прописать требования накладываемые на типы данных для спецификации. Здесь помимо требования сортируемости(которое есть и в оригинальном алгоритме) мы добавляем проверку на то, что проекция имеет тип bool.}
\begin{figure}[t]
\begin{lstlisting}[caption={Предложенная спецификация сортировки}, label={listing::sort}]
template<random_access_iterator Iter,
         sentinel_for<Iter> Sent,
         typename Comp = ranges::less,
         typename Proj = identity>
requires sortable<Iter, Comp, Proj> && std::is_same<Proj, bool>
constexpr Iter
operator()(Iter first, Sent last,
           Comp comp = {}, Proj proj = {}) const {
    auto lasti = ranges::next(first, last);
    partition(first, last, __detail::__make_comp_proj(comp, proj));
    return last;
}
\end{lstlisting}
\end{figure}
\subsection{Тесты и примеры}
